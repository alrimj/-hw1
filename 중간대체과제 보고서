Ⅰ. comparative analysis of 8 algorithms:
1. Bubble Sort vs Insertion Sort vs Selection Sort :
 이들은 모두 구현이 비교적 간단하다는 특징이 있다. 또한 Bubble과 Insertion의 best case의 경우 O(n)이지만 그 외 average나 worst case의 시간 복잡도가 O(n2)이며 추가적인 메모리를 사용하지 않고 주어진 배열 내에서 정렬을 수행하므로 메모리 사용량도 매우 작다는 특징이 존재한다. 
Bubble Sort는 인접한 2개의 데이터를 비교해 정렬되어 있지 않는 경우에 위치를 변경 한다. (마지막-1)번째 데이터까지 비교 및 교환을 수행하면 가장 큰 데이터가 맨 뒤에 위치하며 이 과정을 반복한다. 
Selection Sort는 처리할 대상 범위에서 최솟값을 찾아 그 값과 범위의 맨 앞에 있는 값을 서로 바꾸는 과정을 반복한다. 이 경우 best, average 그리고 worst case 모두 O(n2)이지만 Bubble Sort와 비교하면 대부분의 경우에서 보다 좋은 성능을 보인다고 한다. 
Insertion Sort은 Selection Sort와 비슷하게 작동한다. 배열의 모든 요소를 앞에서부터 차례로 이미 정렬된 배열의 부분과 비교해 위치를 찾아 삽입한다. 그러나 이 정렬 알고리즘들이 구현이 간단하고 이해하기가 쉽다는 장점이 있지만 비교적 큰 dataset에 대해서는 효율적이지 않다. 
비교 횟수가 입력 크기의 제곱에 비례하는 시간 복잡도가 O(n2)인 알고리즘이므로 입력 크기가 커지면 커질수록 정렬하는 데 시간이 굉장히 오래 걸리기 때문이다. 따라서 dataset의 크기가 더 커지거나 효율적인 정렬 알고리즘이 필요한 경우에는 Merge Sort나 Quick Sort와 같은 알고리즘을 사용하는 것이 좋을 것이다. 
이 알고리즘들은 모두 best case에 공간복잡도 O(1)을 가지며, 최악의 경우 O(n)이며 selection만 최악의 경우가 O(n2)이다.

2. Merge Sort vs Quick Sort :
 Merge Sort는 잘 알려져있고 매우 효과적인 정렬 알고리즘이다. 주어진 데이터를 작은 단위로 나눈 다음 각각을 재귀 호출로 풀어 가는 방식을 이용하는데, 
이렇게 큰 문제를 작은 문제로 분할하여 푸는(정복하는) 방법을 ‘분할 정복’이라고 한다. 이는 입력 크기가 커서 풀기 어려웠던 문제도 반복해서 잘게 나누다 보면 굉장히 쉬운 문제(종료 조건)가 될 수 있는데 이러한 원리를 이용한 것이라고 한다. 
이를 활용하면 계산 복잡도가 더 낮은 효율적인 알고리즘을 만드는 데 도움이 된다.  이는 병렬하게 처리할 수 있는 능력이 있기 때문이다. 데이터들이 많고 많은 서브 리스트들로 나뉘기 때문에 나누고 정렬하고 그 후에 합치는 과정이 결과적으로 빠르게 만드는 효과를 나타내는 것이다. 
이러한 분할 정복을 이용한 병합 정렬의 계산 복잡도는 O(n·logn)으로 선택 정렬이나 삽입 정렬의 계산 복잡도 O(n2)보다 낮다. 따라서 정렬해야 할 데이터의 개수가 많을수록 병합 정렬이 선택 정렬이나 삽입 정렬, 버블 정렬보다 훨씬 더 빠른 성능을 나타낸다.
 Quick Sort 또한 분할 정복 전략을 사용하기에 Merge Sort와 유사하다. 하지만 데이터들을 비교하는데 pivot이 필요하다는 점에서 차이가 있다. 
두 알고리즘 모두 평균 시간 복잡도가 O(nlog2n)이다. 하지만 Merge sort는 최악의 경우에도 O(nlog2n)을 보장하는 반면에 Quick sort는 최악의 경우 O(n2)일 수 있다. 
따라서, 데이터가 거의 정렬되어 있는 경우에는 Quick sort보다 Merge sort가 더 효과적일 수 있다. 
이는 Quick sort가 Pivot의 선택에 따라 성능이 크게 달라질 수 있기 때문이다. 즉, Quick Sort에서 pivot은 알고리즘의 성능을 결정짓는 중요한 요인이다. 
하지만, Quick sort는 일반적으로 상수항이 작아 실제로는 Merge sort보다 빠를 수 있다. 특히 작은 크기의 배열에 대해서는 Quick sort가 효율적일 수 있다. 
공간복잡도 측면에서 Merge는 최선으로 O(1), 최악의 경우 O(nlog2n), Quick은 최고 O(logn), 최악의 경우 O(nlog2n)이다.

3. Bucket Sort vs Radix Sort :
Bucket sort와 Radix sort는 모두 정렬 알고리즘 중 비교 정렬이 아닌 알고리즘으로, 데이터의 특성에 따라 효과적인 경우가 있다. 
Bucket Sort는 배열을 여러 개의 버킷에 나누고, 각 버킷 내에서 다른 정렬 알고리즘(일반적으로 삽입 정렬)을 사용하여 정렬한다. 
이는 입력 데이터가 균일하게 분포되어 있을 때 효과적이다. 공간복잡도는 O(n+k)이며 이때 k는 버킷의 수이다.
 Radix Sort는 가장 낮은 자리수부터 가장 높은 자리수까지 순서대로 정렬을 수행한다. 각 자리수를 기준으로 버킷에 데이터를 분배한 후, 정렬된 순서대로 다시 합친다. 정수 데이터의 정렬에 유용하며 자릿수의 크기가 일정한 경우에 특히 효과적이다. Radix Sort의 공간복잡도는 O(n+k)이며 이때 k는 사용하는 임시 배열의 크기이다.
Radix sort는 입력 데이터의 자릿수에 의존하므로 데이터의 범위에 따라 성능이 달라지는 반면, Bucket sort는 입력 데이터의 분포에 더 의존하므로 데이터가 균일하게 분포되어 있을 때 Bucket sort가 더 빠를 수 있다. 
따라서 데이터의 분포와 특성을 고려하여 적절한 알고리즘을 선택해야 한다. 

4. Quick Sort vs Dual-pivot Quick Sort :
 Quick Sort와 비교하였을 때 정복 전략을 사용함은 동일하지만 Dual-pivot Quick Sort는 하나가 아닌 두 개의 pivot을 사용하다는 점에서 차이가 있다. 
이는 배열을 세 부분으로 나누는데 사용되며 일반적으로 Quick Sort보다 더 나은 성능을 보이는 경향이 있다. 
평균적으로는 Quick Sort와 동일하게, O(nlog2n)의 시간 복잡도를 가지지만 최악의 경우는 여전히 O(n2)일 수 있으며, 
이때는 이미 배열이 증가 혹은 감소의 순서로 정렬이 되어있는 경우이다. 둘의 공간 복잡도는 비슷하며 최악의 경우 O(n), 평균적으로는 O(nlog2n)이다.

Ⅱ. Fastest algorithm desciption & comparison:
 먼저 미리 구현한 7가지 알고리즘끼리 execution time을 사용하여 비교해보았으며 이때 quick sort가 가장 빠름을 알 수 있었습니다. 이에 추가적으로 quick sort와 dual pivot quick sort에 대해 execution time을 사용하여 비교해보았으며 dual pivot quick sort가 quick sort보다 조금 더 빠름을 알 수 있었습니다. [그림1]참조.
따라서 이 알고리즘을 최적화 시켰을 때 가장 빠른 알고리즘이 나올 것이라고 가정하게 되었고 dual pivot quick sort에 대해 배열의 크기가 일정 수준에 달하였을 때 삽입 정렬을 하게끔 특정 조건을 적용시켜보았습니다.
삽입 정렬은 작은 데이터 집합에 대해 매우 효율적인 정렬 방법이며, 크기가 작은 배열에 대해 삽입 정렬을 사용함으로써, 전체 정렬 과정의 속도를 개선할 수 있습니다. 
이는 삽입 정렬이 작은 데이터 집합에서는 O(n^2)의 시간 복잡도를 가지지만, 데이터가 이미 거의 정렬되어 있거나 데이터 집합 크기가 작을 때는 매우 빠르기 때문입니다. 
이때의 삽입 정렬을 실행할 조건은 high-low <=5인 즉, 크기가 5이하일 경우이며 이를 통해 성능을 향상시키고자 하였습니다. 이때 기준을 5로 정한 이유는 15~20을 기준으로 하거나 혹은 그 이상의 크기로 지정할 경우에는 기존의 dual pivot quick sort가 오히려 더 빠른 정렬의 속도를 보여주었기 때문입니다. 
또한 공간복잡도는 평균적으로 logn이라 예상합니다. 코드구현에 기존의 알려져있는 dual pivot quick sort 알고리즘을 이용하였으며 보완된 것은 밑과 같습니다. 이후에 quick sort와 dual pivot quick sort, 직접 구현한 Fastest Algorithm(dual pivot quick sort with insertion)의 실행시간을 비교해보았습니다. [그림2]참조. 
이때 각 정렬 알고리즘의 실행 시간을 비교하는 과정에서 보다 정확하고 신뢰성 있는 결과를 얻기 위해 각 함수별로 1000번을 실행하고 그 때의 각 실행 시간의 평균을 산출해보았으며 이때 구현한 Fastest 알고리즘이 가장 빠른 것을 알 수 있었습니다. 
